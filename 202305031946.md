---
tags: [performance, networking]
---

# TCP Reno Algorithm

TCP Reno is a [Transmission Control Protocol (TCP)](202206151232.md)
[congestion control algorithm](202304261438.md) by deciding the sending rate at
the sender side to reduce [Network Congestion](202209302043.md). The sending
rate (bytes per second) is computed by the result from congestion window divided
by [Round-Trip Time (RTT)](202303292133.md). Congestion window is a variable set
at each end of the connection, initially as 1 [Maximum Segment Size (MSS)](202303282019.md),
in TCP that can be used to as a constraint the sending rate of the sender to the
network. Basically, the unacknowledged number of data on the sender must not
exceed the minimum value of from both congestion window and receiver window. The
following mathematical notation clarifies the concept, note that it is similar
to the sender side's [flow control mechanism](202304231611.md):

$$
\begin{align}
\text{last byte sent} - \text{last byte acknoledged} &\le
\text{min}(\text{congestion window}, \text{receiver window})\\ \text{sending
rate} &= \frac{\text{congestion window}}{\text{round-trip time}} \end{align}
$$

There are three main components in this congestion control #algorithm:
additive-increase, multiplicative-decrease (AIMD), slow start (SS), and reaction
to timeout events. Two kinds of loss event are defined by TCP, that is timeout
and 3 duplicated [ACKs](202303141902.md), which happened after a packet was drop
in the network. With AIMD, the sender will cautiously increase the congestion
window size by 1 MSS for each RTT when it received an ACK. This linear
increasing phase is also known as congestion avoidance phase. If triple
duplicated ACKs are received, the sender halves its congestion window size but
not below 1 MSS. The former mechanism is called additive-increase whereas the
latter is multiplicative-decrease. A common approach for the TCP sender to
increase its congestion window size by $\text{congestion window size} +
\text{MSS} \times (\text{MSS}/\text{congestion window size})$. If a timeout
event is detected instead, the congestion window drops to its initial value,
that is 1 MSS, and enter the slow start phase. This introduces another variable
called *threshold*, initialised as a large value (typically 65 Kbytes), that
depends on the halving of congestion window size by multiplicative-decrease.
Coming back to the SS phase, the sender will transmit at 1 MSS rate, but the
sending rate will exponentially according to the number of ACK, that is the
increase of 1 MSS rate for each acknowledged packet for each RTT, until a loss
event is detected. Either the sending rate has reached the threshold or 3
duplicated ACKs have been received (fast recovery), the sender ends its SS phase
and return to congestion avoidance phase.

**Note**: Loss events in congested router will affect all sources' congestion
window size along the path.
